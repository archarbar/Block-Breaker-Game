class Block223 {
   1 <@>- * PlayedGame playedGames;
   1 <@>- * HallOfFameEntry entries;
}

class Game {
   Boolean published = false;
   1 -> 0..1 HallOfFameEntry mostRecentEntry;
}

class PlayedGame {
   const Integer INITIAL_WAIT_TIME = 1000; // at design time, the initial wait time may be adjusted as seen fit
   autounique id;
   const Integer NR_LIVES = 3;
   Integer score = 0;
   Integer lives = NR_LIVES;
   Integer currentLevel = 1;
   Double waitTime = INITIAL_WAIT_TIME;
   * -- 0..1 Player player; // an admin may test the game; a game is played in test mode if player == null
   playername; // added here so that it only needs to be determined once
   
   // the PlayedBall and PlayedPaddle are not in a separate class to avoid the bug in Umple that occurred for the second constructor of Game

   // no direct link to Ball, because the ball can be found by navigating to Game and then Ball
   const Integer BALL_INITIAL_X = Game.PLAY_AREA_SIDE / 2;
   const Integer BALL_INITIAL_Y = Game.PLAY_AREA_SIDE / 2;
   // 0/0 is the top left corner of the play area, i.e., a directionX/Y of 0/1 moves the ball down in a straight line
   defaulted Double ballDirectionX = getGame().getBall().getMinBallSpeedX();
   defaulted Double ballDirectionY = getGame().getBall().getMinBallSpeedY();
   // the position of the ball is at the center of the ball
   defaulted Double currentBallX = BALL_INITIAL_X;
   defaulted Double currentBallY = BALL_INITIAL_Y;

   // no direct link to Paddle, because the paddle can be found by navigating to Game and then Paddle
   const Integer PADDLE_MOVE_RIGHT = 1; // pixels moved when right arrow key is pressed
   const Integer PADDLE_MOVE_LEFT = -1; // pixels moved when left arrow key is pressed
   Double currentPaddleLength = getGame().getPaddle().getMaxPaddleLength();
   // the position of the paddle is at its top right corner
   defaulted Double currentPaddleX = (Game.PLAY_AREA_SIDE - currentPaddleLength) / 2;
   immutable Double currentPaddleY = Game.PLAY_AREA_SIDE - Paddle.VERTICAL_DISTANCE - Paddle.PADDLE_WIDTH;

   * -- 1 Game game;
   1 <@>- * PlayedBlockAssignment blocks;
   0..1 -> 0..1 BouncePoint bounce;
   
   public boolean isBallOutOfBounds(){
   		double xball = this.currentBallX;
   		double yball = this.currentBallY;
   		double xballfuture = this.currentBallX + (this.ballDirectionX)*getWaitTime();
   		double yballfuture = this.currentBallY + (this.ballDirectionY)*getWaitTime();
   		double xwallleft= 0;
   		double ywallleft = Game.PLAY_AREA_SIDE;
   		double xwallright = Game.PLAY_AREA_SIDE;
   		double ywallright = Game.PLAY_AREA_SIDE;
   		
   		return java.awt.geom.Line2D.linesIntersect(xball, yball, xballfuture, yballfuture, xwallleft, ywallleft, xwallright, ywallright);
   	
   }
   private static Point getLineIntersection(Line2D pLine1, Line2D pLine2) {
	   Point result = null;
	   double s1_x = pLine1.getX2() - pLine1.getX1();
	   double s1_y = pLine1.getY2() - pLine1.getY1();
	   double s2_x = pLine2.getX2() - pLine2.getX1();
	   double s2_y = pLine2.getY2() - pLine2.getY1();
	   double s = (-s1_y * (pLine1.getX1() - pLine2.getX1()) + s1_x * (pLine1.getY1() - pLine2.getY1())) / (-s2_x * s1_y + s1_x * s2_y);
	   double t = ( s2_x * (pLine1.getY1() - pLine2.getY1()) - s2_y * (pLine1.getX1() - pLine2.getX1())) / (-s2_x * s1_y + s1_x * s2_y);

	   if(s >= 0 && s <= 1 && t >= 0 && t <= 1) {
		   //This is only true if there is the two lines intersect
		   result = new Point((int) (pLine1.getX1() + (t * s1_x)), (int) (pLine1.getY1() + (t * s1_y)));
	   }
	   return result;
   }
   
   private BouncePoint calculateBouncePointWall() {
	   BouncePoint bouncePoint = null;
	   Point bouncePosition;
	   double ballRadius = 5.0;
	   double wallHeight = Game.PLAY_AREA_SIDE;
	   double xBall = this.currentBallX;
	   double yBall = this.currentBallY;
	   double xBallFuture = this.currentBallX + (this.ballDirectionX)*getWaitTime();
	   double yBallFuture = this.currentBallY + (this.ballDirectionY)*getWaitTime();
	   Line2D.Double leftWall = new Line2D.Double(ballRadius, ballRadius, ballRadius, wallHeight - ballRadius);
	   Line2D.Double topWall = new Line2D.Double(ballRadius, ballRadius, wallHeight - ballRadius, ballRadius);
	   Line2D.Double rightWall = new Line2D.Double(ballRadius, wallHeight - ballRadius, wallHeight - ballRadius, wallHeight - ballRadius);
	   Line2D.Double lineBallPath = new Line2D.Double(xBall, yBall, xBallFuture, yBallFuture);
	   //If it doesn't intersect with any wall, return null
	   if (!(lineBallPath.intersectsLine(leftWall) || lineBallPath.intersectsLine(topWall) || lineBallPath.intersectsLine(rightWall))) {
		   return bouncePoint;
	   }
	   else {
		   if(lineBallPath.intersectsLine(leftWall)) {
			   bouncePosition = getLineIntersection(lineBallPath, leftWall);
			   bouncePoint = new BouncePoint(bouncePosition.getX(), bouncePosition.getY(), BounceDirection.FLIP_X);
			   if( (bouncePosition.getX() == 5 && bouncePosition.getY() == 5) || (bouncePosition.getX() == 385 && bouncePosition.getY() == 5) ) {
				   bouncePoint.setDirection(BounceDirection.FLIP_BOTH);
			   } 
		   }
		   else if(lineBallPath.intersectsLine(topWall)){
			   bouncePosition = getLineIntersection(lineBallPath, topWall);
			   bouncePoint = new BouncePoint(bouncePosition.getX(), bouncePosition.getY(), BounceDirection.FLIP_Y);
			   if( (bouncePosition.getX() == 5 && bouncePosition.getY() == 5) || (bouncePosition.getX() == 385 && bouncePosition.getY() == 5) ) {
				   bouncePoint.setDirection(BounceDirection.FLIP_BOTH);
			   } 
		   }
		   else if(lineBallPath.intersectsLine(rightWall)) {
			   bouncePosition = getLineIntersection(lineBallPath, rightWall);
			   bouncePoint = new BouncePoint(bouncePosition.getX(), bouncePosition.getY(), BounceDirection.FLIP_X);
			   if( (bouncePosition.getX() == 5 && bouncePosition.getY() == 5) || (bouncePosition.getX() == 385 && bouncePosition.getY() == 5) ) {
				   bouncePoint.setDirection(BounceDirection.FLIP_BOTH);
			   } 
		   }
	   }
	   return bouncePoint;
   }
   
   private boolean isCloser(BouncePoint first, BouncePoint second){
  	if (second == null){
  		return true;
  	}
  	if (first == null){
  		return false;
  	}
  	if (Math.sqrt(Math.pow((this.getCurrentBallX()-first.getX()),2.0)+Math.pow((this.getCurrentBallY()-first.getY()),2.0)) <
  		Math.sqrt(Math.pow((this.getCurrentBallX()-second.getX()),2.0)+Math.pow((this.getCurrentBallY()-second.getY()),2.0))){
  			return true;
  	}
  	else{
  	 return false;
  	}
  }
  }
}

class PlayedBlockAssignment {
   // the associated block is either (a) the same as the one of the corresponding BlockAssignent or (b) randomly chosen
   * -- 1 Block block;
   // the position of a block is at its top right corner
   Integer x;
   Integer y;
}

class HallOfFameEntry {
   Integer score;
   playername; // added here so that it only needs to be determined once
   * -- 1 Player player;
   // the sorted keyword keeps the list of entries in the game automatically sorted by the score
   * sorted {score} -- 1 Game game;
}

// this class needs to be specified but the use of it is optional; it is also not added to the persistence file
// you may implement bounce behavior differently
class BouncePoint {
   Double x;
   Double y;
   enum BounceDirection { FLIP_X, FLIP_Y, FLIP_BOTH }
   BounceDirection direction;
   0..1 -> 0..1 PlayedBlockAssignment hitBlock;
}